# 《计算之魂》 Chapter 1
求一个数据序列中和最大的子序列。

假设数组为

a[0], a[1], a[2], a[3], a[4], ... , a[N],

## 三层循环算法
    第一层循环由a[0]到a[n], 循环次数为n+1次。
    第二层循环由a[1]到a[n], 循环次数为n次。
    由第一层，第二层循环，不断将数组切断再组合成新的数组，计算他们的合平均消耗为N/4次。这就是第三层循环。
    由此可见，该算法的时间复杂度为O(n^3)。
   

## 两层循环法
    第一层循环由a[0]到a[n], 循环次数为n+1次。
    第二层循环由a[1]到a[n], 循环次数为n次。
    第二层循环直接存储下中间结果，这样就避免了第三次循环的消耗。

## 分之算法
    分治算法的,根据字面意思就知道是，分而治之。简单的说就是将一个复杂的问题分解成多组相同或类似的子问题，
    对这些子问题再分，然后再分。直到最后的子问题可以简单得求解。

    T(问题规模) = 子问题数 *  T(子问题规模) + 附加计算
    T(n) = O(n*logn)



---
存在的bug

/usr/local/bin/python3.9 /Users/Lewis/RedTeam/readingnotes/计算之魂/Chapter1/main.py
[ 75 -33 -84  81  85  88 -94 -31 -16  13  46  73  -8  27 -52  48 -54 -73
 -43  55  -9 -97 -19 -91 -88  23   2  15 -32  -1 -17  29 -98  49   6 -57
  16 -16 -37 -14 -73 -39  68  64 -21  31  -3  25  -8 -43 -18 -91  95 -78
 -20  63  20  87 -71 -13 -56  66  19 -74  -4 -13  63 -35  89  83  98 -82
  38  21 -59 -15   7  37 -53  97  97 -73  41  98  87 -30   7 -40 -22  22
  -8  40  32  57 -75 -21  15  19 -42  32]
func :threeloop 	time costing:0.021758
622
func :twoloop 	time costing:0.001166
622 [ 68  64 -21  31  -3  25  -8 -43 -18 -91  95 -78 -20  63  20  87 -71 -13
 -56  66  19 -74  -4 -13  63 -35  89  83  98 -82  38  21 -59 -15   7  37
 -53  97  97 -73  41  98  87 -30   7 -40 -22  22  -8  40  32  57]
func :divideConquer 	time costing:0.000198
618 [ 95 -78 -20  63  20  87 -71 -13 -56  66  19 -74  -4 -13  63 -35  89  83
  98 -82  38  21 -59 -15   7  37 -53  97  97 -73  41  98  87 -30   7 -40
 -22  22  -8  40  32  57]
func :function4 	time costing:0.000119
0 []


Divide-and-Conquer(P)

　　1. if |P|≤n0
　　2. then return(ADHOC(P))
　　3. 将P分解为较小的子问题 P1 ,P2 ,…,Pk
　　4. for i←1 to k
　　5. do yi ← Divide-and-Conquer(Pi) △ 递归解决Pi
　　6. T ← MERGE(y1,y2,…,yk) △ 合并子问题
　　7. return(T)

其中|P|表示问题P的规模；n0为一阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。ADHOC(P)是该分治法中的基本子算法，用于直接解小规模的问题P。因此，当P的规模不超过n0时直接用算法ADHOC(P)求解。算法MERGE(y1,y2,…,yk)是该分治法中的合并子算法，用于将P的子问题P1 ,P2 ,…,Pk的相应的解y1,y2,…,yk合并为P的解。